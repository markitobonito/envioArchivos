# Modern docker-compose configuration for QUIC file transfer system
# Compatible with macOS, Linux, and Windows (with Docker Desktop)
#
# Architecture:
#   - Tailscale runs on HOST (not in Docker)
#   - Docker container reads pre-generated tailscale_status.json from host
#   - This avoids network isolation issues and simplifies connectivity
#
# Tested on:
#   ✓ macOS (ARM64/Intel)
#   ✓ Linux (Ubuntu, Fedora, etc.)
#   ✓ Windows (via Docker Desktop)

services:
  quic-file-transfer:
    build:
      context: .
      dockerfile: Dockerfile
    
    # Port mappings for web interface and QUIC server
    ports:
      - "127.0.0.1:8080:9999"    # Flask web: localhost only (browser)
      - "0.0.0.0:9999:9999/tcp"  # Flask TCP: for all interfaces
      - "0.0.0.0:9999:9999/udp"  # QUIC UDP: for peer-to-peer communication
    
    # Volume mounts
    volumes:
      # Application code
      - ./app:/app
      # QUIC certificates
      - ./certs:/certs
      - ./certs:/app/certs
      # Upload/temporary files
      - ./app/uploads:/app/uploads
      # Downloads folder (mounted for video/file output)
      - ${DOWNLOADS_PATH:-$HOME/Downloads}:/root/Downloads
      # Tailscale status (generated by host, read by container)
      - ${SCRIPT_DIR:-./}/app/tailscale_status.json:/app/tailscale_status.json
      # Tailscale socket (for accessing tailscale CLI from container on Linux/macOS)
      - /var/run/tailscale/:/var/run/tailscale/:ro
      - /run/tailscale/:/run/tailscale/:ro
    
    # Working directory inside container
    working_dir: /app
    
    # Environment variables passed to Python app
    environment:
      FLASK_APP: "run.py"
      TAILSCALE_STATUS_PATH: "/app/tailscale_status.json"
      HOST_TAILSCALE_IP: "${HOST_TAILSCALE_IP:-127.0.0.1}"
      FLASK_ENV: "production"
    
    # Container configuration
    privileged: false                  # Do NOT use root privileges
    restart: unless-stopped            # Auto-restart if crashes
    user: "0"                          # Run as root inside container (safe in Docker)
    command: "python3 /run.py"         # Start the app
    
    # Keep container running
    stdin_open: true
    tty: true

# Network configuration
networks:
  default:
    driver: bridge                     # Standard Docker bridge network
