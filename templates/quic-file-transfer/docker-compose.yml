# Minimal modern compose file (no `version` field)
services:
  quic-file-transfer:
    build:
      context: .
      dockerfile: Dockerfile
    # IMPORTANTE: Usar network_mode: host para que Flask escuche en la IP de Tailscale
    # Así Flask está accesible desde 100.x.x.x:5000 y 9999 directo
    network_mode: host
    volumes:
      - ./app:/app
      - ./certs:/certs
      - ./certs:/app/certs
      - ./app/uploads:/app/uploads  # Mapear uploads para accesibilidad en host
      - ${DOWNLOADS_PATH:-$HOME/Downloads}:/root/Downloads  # Mapear Descargas/Downloads del usuario (detectado dinámicamente)
      # mount host's tailscale state so the container can query the host daemon
      - /var/run/tailscale:/var/run/tailscale:ro
      - /var/lib/tailscale:/var/lib/tailscale:ro
    working_dir: /app
    environment:
      FLASK_APP: "run.py"
      # Pass in Tailscale auth key / api key via environment (read from the environment of the runner)
      TAILSCALE_AUTHKEY: "${TAILSCALE_AUTHKEY}"
      TAILSCALE_API_KEY: "${TAILSCALE_API_KEY}"
      TAILNET: "${TAILNET}"
    # Capabilities for Tailscale inside container
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    devices:
      - /dev/net/tun:/dev/net/tun
    restart: unless-stopped
    # Ejecutar como root para poder escribir en cualquier lugar (incluyendo /root/Downloads)
    user: "0"
    # Ejecutar explícitamente /run.py con python3 para evitar que se use run.py relativo a /app
    command: "python3 /run.py"